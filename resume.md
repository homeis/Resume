#简历

##个人概况

* 徐敏 / 男 / 1989
* 工作年限：5 year
* 出生年月：1989年10月
* 期望职位：高级软件开发(架构师方向)
* 期望城市: 深圳(现居住于上海)
* 电话：13916445873
* E-mail：skgin@sina.com


##工作经历 


中国民航信息网络股份有限公司    


2010/12 -- 至今 

**中国航信旅行社信息化解决方案(ETA平台)**

**项目简介：**

* ETA平台是集机票,酒店,景点门票等旅游资源为一体的旅游产品集散平台,系统和各大航空公司对接,
* 提供大量优惠的机票资源:和全国多家酒店合作，实现酒店实时预订;
* 并已经（或即将）与携程、去哪儿、艺龙、淘宝/天猫、京东等代理商接口对接,
* 实现产品一次生成，全网可卖；并实现全网配额动态、实时共享!这在旅游系统中,尚属首次.
* 系统已先后为上航假期、上海航空、厦门航空、香港航空等客户提供优质服务.

**项目架构：**

* ETA项目庞大复杂，已持续开发五年多，使用了多种技术、框架;
* 使用CAS实现一键登录，处处可用，方便在各个子系统中切换;
* 使用Apache+tomcat、Nginx+Tomcat实现代理和负载均衡，提高系统的稳定性;
* 使用ElasticSearch,优化系统日志查询速度；
* 使用Kettle替换存储过程,降低Oracle数据库的压力；
* 使用Oracle + TimesTen搭建数据库层级缓存,提供数据的实时计算，时时响应；
* 使用Maven+Bamboo+Linux Shell，实现项目代码的自动化编译、打包、发布.

**项目职责：**

>(2013 ~ 2015) 项目组长.
>* 部分模块的设计和开发.编写公共模板代码.
>* 给小组成员分配任务并指导完成开发
>* 负责git代码审核及合并.测试环境,生产环境的部署和发布.
>* 消息通知解决方案(RPC解决方案);
	* 使用thrift/rabbitmq完成多个系统间的数据同步(消息通知/通讯),解决不同进程间相互调用、通讯的问题.在分布式开发,大大降低系统之间的耦合度.
>* SSO-单点登录;
	* CAS(Central Authentication Service)+Spring-Security 使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统.
>* 缓存解决方案;
	* 使用redis + 动态代理(spring aop)实现产品查询的缓存及统计;
	* 使用rabbitmq 异步消息通知实现缓存数据库与实体数据之间数据同步;
	* 使用timesten 实现缓存数据库分库,oracle triggers + java + jotm 实现数据同步;

>(2011 ~ 2013) 软件开发工程师 
主要任是根据项目需求完成各个模块的开发.
主要使用技术:spring hibernate struts2 jquery dwr
.系统登陆
.酒店管理
.渠道管理
.优惠管理
.产品导入
.价格配额管理
.google map(已弃用)
.行程管理
.酒店订单管理
.团队成本结算(报表)
.缓存管理
.用户消息通知 等;
>


##技能清单

* 编程语言：java/j2ee/javascript/jquery/dwr
* 内存数据库:redis/timesten
* sso: yale cas
* 消息通知:thrift/rabbitmq
* 开发工具: Inteillj idea/Myeclipse/pl sql/powerDesigner/tomcat
* 服务端框架: spring/struts2/hibernate
* 数据库:oracle
* 项目管理:svn/git+maven/jira
* 缓存框架:oschache


##自我评价

* Java基础扎实，有良好的开发规范，并重视开发规范在项目开发中的主要作用;
* 对工作认真仔细，负责缓存数据的维护工作；
* 掌握缓存技术、消息通知技术的设计和开发； 
* 编写过框架性的代码，具备做架构的潜力；
* 具有管理才能，作为组长带领组员负责各个模块相关功能的设计、开发与维护工作；
* 对工作全心投入，获得部门"明星员工"称号；
* 善于发现问题，解决问题,一切问题都在日志中。


##致谢
感谢您花时间阅读我的简历，期待能有机会和您共事。

<!--
------------------------------------------------------------------------------------------------------------------
  不知不觉在公司已经干了5年了.前三年一直在增删改查之类的,没什么特别.
  三年下来不知不觉也有一些收获.比如类和类的关系,在第一年我只知道用继承;第二年我了解到需要组合;第三年发现还可以委托;
  有时候也会有一些顿悟,比如写过一些架构性代码之后才明白 原来private ,protected,final修饰词用来保护代码中脆弱的模块;
  由于数据也越来越多,数据同步必须异步去做,查询也会变慢,所以要用到缓存.
  项目越来越大,不得把许多模块,拆分成子项目,所以要用统一的登陆系统.
  一次由多线程没有正确shutdown从而导致服务器挂掉.使意识到项目,服务器监控的重要性.
  也有不好地方就是习惯了java那种条条框框的面向对象后,写javascript的面向对象总怪怪的.语言特性方面无法满足,总写不好;
  你技术的高度最主要的是你做的项目的高度决定的，和你平时自学了多少关系不大。
  也就是说你平日的网上的自学最多提高知识面的广度，而技术的高度主要是由你做的产品的特性决定的。
  所以有机会去开发一个好的产品是幸运的，需要机遇。好的产品才养人。 
  技术提高并不需要特别的努力。由于平时的工作内容就是最好的提升材料.  
  技术积累就像一种修行.要一步一个脚印日积月累的改善和提高.
------------------------------------------------加油----------------------------------------------------------------


----------------------------------------------面试整理------------------------------------------------------------------



rpc:大型软件系统开发需要模块化，在分布式系统中，模块化通常是将功能分成不同的远程服务（RPC）来实现。
比如可以用Java RMI、Web Service、Facebook开源的Thrift等一些技术。
同样，在一个大型系统中，服务化之后服务的可维护、可管理、可监控以及高可用、负载均衡等因素同服务本身同样重要;

快速失败，这个在本厂意义重大，很多远程服务调用是在关键路径中，它可以容忍失败，但是不能容忍堵塞
failover，客户端failover支持，并支持自动失效探测及恢复调用
中心化配置及推送功能，所有client在同一时刻配置的一致性，并且client会跟配置中心保持长连
负载均衡策略：支持round robin，least active, consistent hash，或者基于脚本的动态路由策略。这个都是由配置中心来控制
动态启用及停用服务及节点：可以动态启动及停用服务（热发布），由于有推送功能，相对容易实现
跨语言：支持client能使用常见主流语言来访问
版本管理：同一服务可以有不同的版本并存
访问统计及动态运行参数查看：可以对方法级别进行访问统计及实时观察

访问策略

服务框架倾向于直连的方案，即client是直接连接server，而不会增加中间物理上的代理层，服务框架只做中心配置、访问策略、服务发现、配置通知等职责。

路由的特殊需求

通常的服务访问，使用上述round robin等3种策略即可，但是在实际工程实践中，我们发现有些不同的需求。比如计数这样的远程服务，
读操作可随机访问一台远程节点，但写操作需要访问所有的服务节点才能实现。因此我们需要有广播式的访问需求。由于计数服务对实时性和一致性要求较高，
不适合采用异步如Pub/Sub这样方式去实现，因此在 client还需要支持同步的广播调用。

耦合及侵入的矛盾

在设计服务管理系统之前，我们希望不跟一种具体的技术（如Thrift）绑定，比如client和server服务实现方不需要太多关心底层技术。但是在实际实现过程中碰到不少矛盾。

rabbitmq :
erlang 消息机制，高并发，时间检验的高可靠，高性能，集群易扩展，强大的管理功能 ，方便的问题定位支持，


1）String

常用命令：set/get/decr/incr/mget等；

应用场景：String是最常用的一种数据类型，普通的key/value存储都可以归为此类；

实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，
当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。

2）Hash

常用命令：hget/hset/hgetall等

应用场景：我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，
通过用户ID我们希望获取该用户的姓名或者年龄或者生日；

实现方式：Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。
如图2所示，Key是用户 ID, value是一个Map。这个Map的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的 
Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。当前HashMap的实现有两种方式：
当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存 储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，
当成员数量增大时会自动转成 真正的HashMap,此时encoding为ht。

 image
图2 Redis的Hash数据类型

3）List

常用命令：lpush/rpush/lpop/rpop/lrange等；

应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现；

实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。

4）Set

常用命令：sadd/spop/smembers/sunion等；

应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，
set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的；

实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。

5）Sorted Set

常用命令：zadd/zrange/zrem/zcard等；

应用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，
并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，
比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。

实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，
而跳跃表里存放的 是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

1. 要进行Master-slave配置，出现服务故障时可以支持切换。
2. 在master侧禁用数据持久化，只需在slave上配置数据持久化。
3. 物理内存+虚拟内存不足，这个时候dump一直死着，时间久了机器挂掉。这个情况就是灾难！
4. 当Redis物理内存使用超过内存总容量的3/5时就会开始比较危险了，就开始做swap,内存碎片大
5. 当达到最大内存时，会清空带有过期时间的key，即使key未到过期时间.
6. redis与DB同步写的问题，先写DB，后写redis，因为写内存基本上没有问题 

三、Redis有什么用？只有了解了它有哪些特性，我们在用的时候才能扬长避短，为我们所用：

1. 速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万
2. 持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof)
3. 自动操作：对不同数据类型的操作都是自动的，很安全
4. 快速的主--从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。
5. Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，
但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，
Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。

一、Redis是什么？两句话可以做下概括：

1. 是一个完全开源免费的key-value内存数据库
2. 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets

jotm ： 分布试事务管理(多数据源).
-->
